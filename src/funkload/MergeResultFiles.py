# (C) Copyright 2010 Nuxeo SAS <http://nuxeo.com>
# Author: bdelbosc@nuxeo.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
"""Merge FunkLoad result files to produce a report for distributed bench
reports."""
import xml.parsers.expat
from xml.etree.ElementTree import Element, tostring
from utils import trace
from xml.sax.saxutils import quoteattr, escape
import json

class EndOfConfig(Exception):
    pass

class FunkLoadConfigXmlParser:
    """Parse the config part of a funkload xml results file."""
    def __init__(self):
        """Init setup expat handlers."""
        self.current_element = [{'name': 'root'}]
        self.cycles = None
        self.cycle_duration = 0
        self.nodes = {}
        self.stats_files = 0
        self.config = {}
        self.files = []
        self.current_file = None
        self.fl_version = None
        self.fl_time = None

    def parse(self, xml_file):
        """Do the parsing."""
        self.current_file = xml_file
        parser = xml.parsers.expat.ParserCreate()
        parser.StartElementHandler = self.handleStartElement
        try:
            parser.ParseFile(file(xml_file))
        except xml.parsers.expat.ExpatError as msg:
            if (self.current_element[-1]['name'] == 'funkload'
                and str(msg).startswith('no element found')):
                print "Missing </funkload> tag."
            else:
                print 'Error: invalid xml bench result file'
                if len(self.current_element) <= 1 or (
                    self.current_element[1]['name'] != 'funkload'):
                    print """Note that you can generate a report only for a
                    bench result done with fl-run-bench (and not on a test
                    result done with fl-run-test)."""
                else:
                    print """You may need to remove non ascii char that comes
                    from error pages catched during the bench. iconv
                    or recode may help you."""
                print 'Xml parser element stack: %s' % [
                    x['name'] for x in self.current_element]
                raise
        except EndOfConfig:
            return

    def handleStartElement(self, name, attrs):
        """Called by expat parser on start element."""
        if name == 'funkload':
            if self.fl_version and self.fl_version != attrs['version']:
                trace('Skipping file %s generated by different funkload version' % self.current_file)
            self.fl_version = attrs['version']
            
            if self.fl_time:
                self.fl_time = min(self.fl_time, attrs['time'])
            else:
                self.fl_time = attrs['time']
        elif name == 'config':
            self.config[attrs['key']] = attrs['value']
            if attrs['key'] == 'duration':
                if self.cycle_duration and attrs['value'] != self.cycle_duration:
                    trace('Skipping file %s with different cycle duration %s' % (self.current_file, attrs['value']))
                    raise EndOfConfig
                self.cycle_duration = attrs['value']
            elif attrs['key'] == 'cycles':
                if self.cycles and json.loads(attrs['value']) != self.cycles:
                    trace('Skipping file %s with different cycles %s != %s' % (self.current_file, attrs['value'], self.cycles))
                    raise EndOfConfig
                self.cycles = json.loads(attrs['value'])
            elif attrs['key'] == 'node':
                self.nodes[self.current_file] = attrs['value']
            elif attrs['key'] == 'stats_only':
                self.stats_files += 1
        else:
            self.files.append(self.current_file)
            raise EndOfConfig

class FunkLoadContentMergeParser:
    def __init__(self, output, node_count):
        self.output = output
        self.skipped_elements = ('config', 'funkload')
        self.node_count = node_count

    def parse(self, filename, node_id):
        self.node_id = node_id
        parser = xml.parsers.expat.ParserCreate()
        parser.StartElementHandler = self.handleStartElement
        parser.EndElementHandler = self.handleEndElement
        parser.CharacterDataHandler = self.handleCharData

        with open(filename) as xml_file:
            parser.ParseFile(xml_file)

    def handleStartElement(self, name, attrs):
        if name in self.skipped_elements:
            return

        if 'thread_id' in attrs:
            attrs['thread_id'] = "{node}-{thread}".format(
                node = self.node_id,
                thread = attrs['thread_id']
            )

        if 'cvus' in attrs:
            attrs['cvus'] = str(int(attrs['cvus'])*self.node_count)

        self.output.write("<{name} {attrs}>".format(
            name=name,
            attrs=" ".join('{name}={value}'.format(name=name, value=quoteattr(value))
                for (name, value) in attrs.items()),
        ))

    def handleEndElement(self, name):
        if name in self.skipped_elements:
            return

        self.output.write("</{name}>".format(name=name))

    def handleCharData(self, data):
        self.output.write(escape(data))



def replace_all(text, dic):
    for i, j in dic.iteritems():
        if isinstance(text, str):
            text = text.decode('utf-8', 'ignore')
        text = text.replace(i, j)
    return text.encode('utf-8')


class MergeResultFiles:
    def __init__(self, input_files, output_file):
        xml_parser = FunkLoadConfigXmlParser()
        for input_file in input_files:
            trace (".")
            xml_parser.parse(input_file)

        node_count = len(xml_parser.files) - xml_parser.stats_files

        # compute cumulated cycles
        node_cycles = xml_parser.cycles
        cycles = map(lambda x: x * node_count, node_cycles)

        # If we don't have any node cycles, we'll assume that this doesn't hold
        # valid data.

        # node names
        node_names = []
        for i, input_file in enumerate(xml_parser.files):
            node_names.append(xml_parser.nodes.get(input_file, 'node-' + str(i)))
        trace("\nnodes: %s\n" % ', '.join(node_names))
        trace("cycles for a node:    %s\n" % node_cycles)
        trace("cycles for all nodes: %s\n" % cycles)

        config = xml_parser.config.copy()
        config['cycles'] = json.dumps(cycles)

        with open(output_file, 'w+') as output:
            output.write('<funkload version="{version}" time="{time}">\n'.format(
                version=xml_parser.fl_version,
                time=xml_parser.fl_time
            ))
            for key, value in config.iteritems():
                output.write(tostring(Element('config', key=key, value=value)))
                output.write('\n')

            mergeParser = FunkLoadContentMergeParser(output, node_count)
            for i, input_file in enumerate(xml_parser.files):
                mergeParser.parse(input_file, i)
            output.write("</funkload>\n")



